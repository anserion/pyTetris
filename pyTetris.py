# Copyright 2021 XXXXXX XX XXXXXXXX (XXXXXXXX @ XXXXX.XXX)
# имя автора скрыто по условиям задания
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ------------------------------------------------------

# pyTetris - старый добрый ламповый тетрис: )
# созданный при помощи библиотеки pygame на языке Python3

# Для запуска программы выполнить в командной строке
# рабочего каталога программы:
#   (skiped)@linux_box: python3 pyTetris.py
# ------------------------------------------------------

# ------------------------------------------------------
# Если что-то "пошло не так".
# 1) установить Linux (тестировалось на Linux Mint 2020.1)
# 2) для установки python3 выполнить:
#   (skiped)@linux_box: sudo apt install python3
# 3) для установки библиотеки pygame выполнить:
#   (skiped)@linux_box: sudo python3 -m pip install pygame
# ------------------------------------------------------

# ------------------------------------------------------
# Что собственно программа делает
# ------------------------------------------------------
# После запуска программы отрисовывается лого-слайд с надписью "Тетрис"
# в центре и после небольшой задержки главное окно, содержащее:
# 1) случайным образом выбранный фон из картинок рабочего каталога программы
# 2) надпись "Тетрис" в верхней части главного окна
# 3) падающее в расчерченный стакан тетрамино, управляемое игроком
# 4) расчерченный стакан, постепенно заполняемый падающими в него тетрамино
# 5) изображение следующего падающего тетрамино в левом верхнем углу
# 6) надпись "очки:" и количество набранных игровых очков
# 7) надпись "линии:" и количество полностью заполненных линий
# 8) надпись "скорость:" и текущая скорость падения тетрамино в стакан
# 9) надпись "рекорд:" и максимальное набранное за игру количество очков
# 10) если падающие в стакан тетрамино полностью заполняют ряд (несколько
#    рядов), то эти ряды уничтожаются, а все вышестоящие ряды опускаются вниз
#    на место уничтоженных, начисляются игровые очки из расчета 100 очков
#    за уничтоженную линию, 300 очков на две уничтоженные линии,
#    700 очков за три уничтоженные линии и 1500 очков за 4 уничтоженные линии
# 11) если стакан переполнился, то он очищается, производится смена фоновой
#   картинки, скорость падения тетрамино уменьшается до исходной,
#   счетчик игровых очков и уничтоженных линий обнуляется, счетчик рекорда
#   остается
# 12) если пользователь (игрок) нажмет кнопку "ESC" на клавиатуре, то
#    произойдет незамедлительный выход из программы

# ------------------------------------------------------
# Цель игры:
# ------------------------------------------------------
# Набрать как можно больше очков, не допуская переполнения стакана
# падающими в него тетрамино.

# ------------------------------------------------------
# Логика работы компьютерной программы (игры):
# ------------------------------------------------------
# 1) Нажатие на клавиатуре кнопки "стрелка влево" приводит к перемещению
#   падающего тетрамино влево, но не далее левой границы стакана, что
#   позволяет более равномерно распределять тетрамино в стакане
# 2) Нажатие на клавиатуре кнопки "стрелка вправо" приводит к перемещению
#   падающего тетрамино вправо, но не далее правой границы стакана, что
#   позволяет более равномерно распределять тетрамино в стакане
# 3) Нажатие на клавиатуре кнопки "стрелка вниз" приводит к ускорению
#   падения текущего тетрамино
# 4) Нажатие на клавиатуре кнопки "стрелка вверх" приводит к вращению
#   тетрамино на угол 90 градусов
# 5) Нажатие на клавиатуре кнопки "ESC" приводит к выходу из программы
# 6) Скопление тетрамино в стакане в сплошной ряд без пустых мест
#   приводит к уничтожению этого ряда и опусканию всех вышестоящих рядов,
#   что позволяет продлить игру и получить игровые очки
# 7) тетрамино падают с постоянным (небольшим) увеличением скорости падения
# ------------------------------------------------------

# ------------------------------------------------------------------------
# импорт библиотек
# ------------------------------------------------------------------------
import pygame                         # основная библиотека
from random import choice, randrange  # генераторы случайных чисел
from copy import deepcopy             # копирование списочных структур
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# подпрограмма расчета кода случайного цвета в формате (R,G,B)
# ------------------------------------------------------------------------
def rnd_color(): return (randrange(100, 250), randrange(100, 250), randrange(100, 250))
# ------------------------------------------------------------------------
# конец подпрограммы rnd_color
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# подпрограмма вывода первого слайда программы (лого)
# ------------------------------------------------------------------------
def drawLogo():
    logo_font = pygame.font.Font(None, 50)
    label_logo = logo_font.render("Тетрис", True, pygame.Color('gold'))
    logo_width = label_logo.get_width()
    logo_height = label_logo.get_height()
    logo_x = wnd_width // 2 - logo_width // 2
    logo_y = wnd_height // 2 - logo_height // 2
    screen.blit(label_logo, (logo_x, logo_y))
    pygame.display.flip()
    clock.tick(1)
# ------------------------------------------------------------------------
# конец подпрограммы drawLogo
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# подпрограмма
# ------------------------------------------------------------------------
def drawLabels():
    screen.blit(label_tetris, ((wnd_width - label_tetris.get_width()) // 2, 10))
    screen.blit(label_score, (10, 250))
    screen.blit(font.render(str(score), True, pygame.Color("white")), (120, 250))
    screen.blit(label_lines, (10, 275))
    screen.blit(font.render(str(lines_total), True, pygame.Color("white")), (120, 275))
    screen.blit(label_speed, (10, 300))
    screen.blit(font.render(str(int(cnt_inc)), True, pygame.Color("white")), (120, 300))
    screen.blit(label_record, (10, 350))
    screen.blit(font.render(str(record_score), True, pygame.Color("white")), (120, 350))
# ------------------------------------------------------------------------
# конец подпрограммы drawLabels
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# подпрограмма рисования объекта тетрамино на теневом экране
# ------------------------------------------------------------------------
def drawTetramino(tetramino, sx, sy, color):
    brick = pygame.Rect(0, 0, brick_width - 2, brick_height - 2)
    for i in range(4):
        brick.x = tetramino[i].x * brick_width + sx
        brick.y = tetramino[i].y * brick_height + sy
        pygame.draw.rect(screen2, color, brick)
# ------------------------------------------------------------------------
# конец подпрограммы drawTetramino
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# подпрограмма рисования расчерченного стакана и его содержимого
# ------------------------------------------------------------------------
def drawBox(left, top):
    grid_brick = pygame.Rect(0, 0, brick_width, brick_height)
    brick = pygame.Rect(0, 0, brick_width - 1, brick_height - 1)
    for i in range(box_height):
        for j in range(box_width):
            grid_brick.x = j * brick_width + left
            grid_brick.y = i * brick_height + top
            pygame.draw.rect(screen2, pygame.Color(100, 100, 100), grid_brick, 1)
            color = box[i][j]
            if color != None:
                brick.x = grid_brick.x
                brick.y = grid_brick.y
                pygame.draw.rect(screen2, color, brick)
# ------------------------------------------------------------------------
# конец подпрограммы drawBox
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# подпрограмма проверки базового блока тетрамино на пересечение границ
# стакана или столкновение с блоками, уже находящимися в стакане
# ------------------------------------------------------------------------
def check_brick(brick):
    if (brick.x < 0) or (brick.x > box_width - 1):
        return False
    elif (brick.y > box_height - 1) or (box[brick.y][brick.x] != None):
        return False
    return True
# ------------------------------------------------------------------------
# конец подпрограммы check_brick
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# подпрограмма пересчета координат тетрамино после падения на 1 строку вниз
# если тетрамино упирается в дно стакана или в блоки от других тетрамино,
# уже лащие в стакане, то тетрамино разрушается и возвращается None
# ------------------------------------------------------------------------
def tetraminoShiftDown(tetramino):
    tetramino_orig = deepcopy(tetramino)
    for i in range(4):
        tetramino[i].y = tetramino[i].y + 1
        if not check_brick(tetramino[i]):
            tetramino = deepcopy(tetramino_orig)
            for k in range(4):
                brick = tetramino_orig[k]
                box[brick.y][brick.x] = current_color
            return None
    return tetramino
# ------------------------------------------------------------------------
# конец подпрограммы tetraminoShiftDown
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# подпрограмма пересчета координат тетрамино после сдвига на 1 клетку влево
# но не далее левой стенки стакана и без столкновения с блоками от других
# тетрамино, уже лежащими в стакане
# ------------------------------------------------------------------------
def tetraminoShiftLeft(tetramino):
    tetramino_orig = deepcopy(tetramino)
    for i in range(4):
        tetramino[i].x = tetramino[i].x - 1
        if not(check_brick(tetramino[i])):
            tetramino = deepcopy(tetramino_orig)
            return tetramino_orig
    return tetramino
# ------------------------------------------------------------------------
# конец подпрограммы tetraminoShiftLeft
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# подпрограмма пересчета координат тетрамино после сдвига на 1 клетку вправо
# но не далее правой стенки стакана и без столкновения с блоками от других
# тетрамино, уже лежащими в стакане
# ------------------------------------------------------------------------
def tetraminoShiftRight(tetramino):
    tetramino_orig = deepcopy(tetramino)
    for i in range(4):
        tetramino[i].x = tetramino[i].x + 1
        if not(check_brick(tetramino[i])):
            tetramino = deepcopy(tetramino_orig)
            return tetramino_orig
    return tetramino
# ------------------------------------------------------------------------
# конец подпрограммы tetraminoShiftRight
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# подпрограмма пересчета координат тетрамино после его вращения, но
# без столкновения со стенками стакана и с блоками от других тетрамино,
# уже лежащими в стакане
# ------------------------------------------------------------------------
def tetraminoRotate(tetramino):
    center = tetramino[0]
    tetramino_orig = deepcopy(tetramino)
    for i in range(4):
        x = tetramino[i].y - center.y
        y = tetramino[i].x - center.x
        tetramino[i].x = center.x - x
        tetramino[i].y = center.y + y
        if not(check_brick(tetramino[i])):
            return tetramino_orig
    return tetramino
# ------------------------------------------------------------------------
# конец подпрограммы tetraminoRotate
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# подпрограмма поиска полностью заполненных линий после падения тетрамино
# в стакан, уничтожения этих линий и сдвига содержимого стакана вниз
# ------------------------------------------------------------------------
def filledLinesSearch():
    lines_fit = 0
    for i in range(box_height - 1, -1, -1):
        tmp_cnt = 0
        for j in range(box_width):
            if box[i][j] != None:
                tmp_cnt = tmp_cnt + 1
            box[i + lines_fit][j] = box[i][j]
        if tmp_cnt == box_width:
            print("строка", i, "заполнена")
            lines_fit = lines_fit + 1

    if lines_fit > 0:
        print("заполнено", lines_fit, "линий, на", score_rules[lines_fit], "очков")
    return lines_fit
# ------------------------------------------------------------------------
# конец подпрограммы filledLinesSearch
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# инициализационная часть программы
# ------------------------------------------------------------------------
# установка ширины и высоты стакана в базовых блоках тетрамино
box_width = 10
box_height = 16
# инициализация содержимого стакана указателями None
box = [[None for i in range(box_width)] for j in range(box_height)]

# базовая структура, содержащая смещения каждого базового блока тетрамино
# относительно опорной точки (0,0)
# первый кортеж дополнительно считается центром вращения тетрамино
tetra_pack = [[(-1, 0), (-2, 0), (0, 0), (1, 0), "I"],    # I-тетрамино
              [(0, -1), (-1, -1), (-1, 0), (0, 0), "O"],  # O-тетрамино
              [(-1, 0), (-1, 1), (0, 0), (0, -1), "S"],   # S-тетрамино
              [(0, 0), (-1, 0), (0, 1), (-1, -1), "Z"],   # Z-тетрамино
              [(0, 0), (0, -1), (0, 1), (-1, -1), "L"],   # L-тетрамино
              [(0, 0), (0, -1), (0, 1), (-1, 1), "J"],    # J-тетрамино
              [(0, 0), (0, -1), (0, 1), (-1, 0), "T"]]    # T-тетрамино

# пересчитываем кортежи смещений базовых блоков тетрамино в объекты
# pygame.Rect так, чтобы координаты (0,0) каждого тетрамино
# соответствовали середине первой линиии стакана
for tetramino in tetra_pack:
    for i in range(4):
        tetramino[i] = pygame.Rect(tetramino[i][0] + box_width // 2, tetramino[i][1] + 1, 1, 1)

# выбираем случайным образом первый тетрамино
current_tetramino = deepcopy(choice(tetra_pack))
# и его цвет
current_color = rnd_color()
# выводим в консоль сообщение о сделанном выборе
print("запуск", current_tetramino[4] + "-тетрамино цвета", current_color)

# сразу определим какой тетрамино будет падать в стакан вторым
next_tetramino = deepcopy(choice(tetra_pack))
# и его цвет
next_color = rnd_color()
# выводим в консоль сообщение о сделанном выборе
print("следующий", next_tetramino[4] + "-тетрамино цвета", next_color)

# инициализируем счетчик очков
score = 0
# инициализируем счетчик заполненных полностью линий
lines_total = 0
# прописываем правила начисления очков на основании количества заполненных линий
score_rules = {0: 0, 1: 100, 2: 300, 3: 700, 4: 1500}
# обнуляем рекорд
record_score = 0
# ------------------------------------------------------------------------

# желательная скорость обновления экрана
FPS = 60
# внутренний счетчик скорости падения тетрамино
cnt = 0
# параметр, отвечающий за скорость падения тетрамино
cnt_inc = 50
# порог срабатывания счетчика падения тетрамино
cnt_limit = 2000

# ширина главного окна (в пикселях)
wnd_width = 400
# высота главного окна (в пикселях)
wnd_height = 440
# синтаксический сахар, облегчающий восприятие связки (ширина х высота)
wnd_size = (wnd_width, wnd_height)

# ширина базового блока тетрамино (в пикселях)
brick_width = 20
# высота базового блока тетрамино (в пикселях)
brick_height = 20

# смещение верхней границы стакана относительно верхней границы главного окна
box_top = 100
# смещение левой границы стакана относительно левой границы главного окна
box_left = 180

# инициализируем библиотеку pygame
pygame.init()
# создаем главное полотно рисования
screen = pygame.display.set_mode(wnd_size)
# сразу устанваливаем заголовок главного окна
pygame.display.set_caption('pyTetris - Тетрис')
# создаем теневой буфер
screen2 = pygame.Surface(wnd_size)
# создаем таймер
clock = pygame.time.Clock()

# создадим несколько ресурсов-шрифтов и основанных на них статичных надписей
# создание ресурса главного шрифта
font = pygame.font.Font(None, 32)
# создание статичных надписей для последующего быстрого вывода
label_tetris = font.render('Тетрис', True, pygame.Color('red'))
label_speed = font.render('скорость:', True, pygame.Color('green'))
label_score = font.render('очки:', True, pygame.Color('green'))
label_lines = font.render('линий:', True, pygame.Color('green'))
label_record = font.render('рекорд:', True, pygame.Color('yellow'))
# ------------------------------------------------------------------------

# загрузим фоновые изображения в список из которого их будет удобно
# выводить в теневой буфер до прорисовки остальной графики
# предположим, что изображения находятся в рабочем каталоге программы
# формировать загрузку из подкаталога "img" не будем, чтобы не нарываться
# на баги разного представления обратного слэша в linux и windows.
game_background = list()
game_background.append(pygame.image.load('bg1.jpg').convert())
game_background.append(pygame.image.load('bg2.jpg').convert())
game_background.append(pygame.image.load('bg3.jpg').convert())
game_background.append(pygame.image.load('bg4.jpg').convert())
game_background.append(pygame.image.load('bg5.jpg').convert())
game_background.append(pygame.image.load('bg6.jpg').convert())
game_background.append(pygame.image.load('bg7.jpg').convert())
game_background.append(pygame.image.load('bg8.jpg').convert())
game_background.append(pygame.image.load('bg9.jpg').convert())
game_background.append(pygame.image.load('bg10.jpg').convert())
game_background.append(pygame.image.load('bg11.jpg').convert())
game_background.append(pygame.image.load('bg12.jpg').convert())
game_background.append(pygame.image.load('bg13.jpg').convert())
# случайным образом выберем какое из изображений будет первым фоновым
bg_idx = randrange(13)
# пишем в консоль результат выбора
print("выбран фон", bg_idx)
# ------------------------------------------------------------------------

# отрисовываем с задержкой первый слайд (лого) программы
drawLogo()
# инициализируем флаг нормальной работы программы
running = True
# входим в главный цикл
while running:
    # перебрасываем теневой буфер на видимое полотно
    screen.blit(screen2, (0, 0))
    # отрисовываем на теневом буфере фоновое изображение
    screen2.blit(game_background[bg_idx], (0, 0))

    # осущесвляем разбор пришедших сообщений от контроллеров
    # (нас будет интересовать только клавиатура)
    for event in pygame.event.get():
        # если пользователь закрыл программы (например, крестиком в углу)
        if event.type == pygame.QUIT:
            # то сбросить флаг нормальной работы, что приведет в выходу
            # из программы на следующей итерации главного цикла
            running = False
            
        # разбор сообщений от клавиатуры
        if event.type == pygame.KEYDOWN:
            # если нажата клавиша "ESC"
            if event.key == pygame.K_ESCAPE:
                # то вывести в консоль сообщение о готовности выйти из программы
                print("выход из программы")
                # сбросить флаг нормального работы и выйти из главного цикла
                # на следующей итерации
                running = False

            # если нажата кнопка "стрелка влево"
            elif event.key == pygame.K_LEFT:
                # то персчитать координаты падающего тетрамино (сдвиг влево)
                current_tetramino = tetraminoShiftLeft(current_tetramino)
                # вывести в консоль диагностическое сообщение
                print("сдвиг тетрамино влево")

            # если нажата кнопка "стрелка вправо"
            elif event.key == pygame.K_RIGHT:
                # то персчитать координаты падающего тетрамино (сдвиг вправо)
                current_tetramino = tetraminoShiftRight(current_tetramino)
                # вывести в консоль диагностическое сообщение
                print("сдвиг тетрамино вправо")

            # если нажата кнопка "стрелка вверх"
            elif event.key == pygame.K_UP:
                # то персчитать координаты тетрамино после поворота на
                # угол 90 градусов
                current_tetramino = tetraminoRotate(current_tetramino)
                # вывести в консоль диагностическое сообщение
                print("вращение тетрамино")

            # если нажата кнопка "стрелка вниз"
            elif event.key == pygame.K_DOWN:
                # то уменьшить порог срабатывания счетчика скорости падения
                # что приведет к десятикратному увеличению скорости падения
                cnt_limit = 200
                # вывести в консоль диагностическое сообщение
                print("сброс тетрамино вниз")


    # увеличиваем счетчик скорости падения тетрамино
    cnt = cnt + cnt_inc
    # до достижения порога срабатывания
    # (чем меньше порог и больше приращение, тем быстрее сработает)
    # если порого срабатывания достигнут, то опускаем тетрамино на 1 линию вниз
    if cnt > cnt_limit:
        # обнуляем счетчик
        cnt = 0
        # увеличиваем приращение (скорость достижения порога срабатывания)
        cnt_inc = cnt_inc + 0.1
        # персчитываем координаты падающего тетрамино (сдвиг вниз на 1 линию)
        current_tetramino = tetraminoShiftDown(current_tetramino)
        # выводим в консоль диагностическое сообщение
        print("сдвиг тетрамино вниз")
        # если тетрамино столкнулся с дном стакана или другим его содержимым
        if current_tetramino == None:
            # то заменяем текущий тетрамино заранее сгенерированным дублером
            current_tetramino = next_tetramino
            # также передаем цвет дублера возрождаемому тетрамино
            current_color = next_color
            # генерируем нового дублера, который заменит текущего тетрамино
            # после его следующего уничтожения
            next_tetramino = deepcopy(choice(tetra_pack))
            next_color = rnd_color()
            # выводим в консоль диагностическое сообщение
            print("следующий", next_tetramino[4] + "-тетрамино цвета", next_color)
            # так как уничтожение текущего тетрамино могло произойти
            # после его ускоренного падения, то восстанавливаем порог
            # срабатывания скорости падения тетрамино
            cnt_limit = 2000
            # определяем сколько заполненных линий возникло после падения тетрамино
            lines_fit = filledLinesSearch()
            # обновляем счетчики
            # сколько всего линий повезло уничтожить игроку
            lines_total = lines_total + lines_fit
            # заработанные игроком очки
            score = score + score_rules[lines_fit]
            # проверяем достижение нового рекорда
            if score > record_score:
                record_score = score

    # перерисовываем расчерченный стакан и его содержимое
    drawBox(box_left, box_top)
    # отрисовываем падающий в стакан тетрамино
    drawTetramino(current_tetramino, box_left, box_top, current_color)
    # рисуем тетрамино, который будет падать в стакан следующим
    drawTetramino(next_tetramino, 0, 20, current_color)
    # рисуем текстовые сообщения (игровые счетчики)
    drawLabels()

    # выполним проверку на переполнение стакана падающими тетрамино
    # для этого убедимся, что на самой верхней строчке стакана нет
    # ни одного базового блока тетрамино
    for i in range(box_width):
        # если же такой блок найдется
        if box[0][i] != None:
            # то выводим в консоль диагностическое сообщение
            print("конец раунда")
            # очищаем стакан
            box = [[None for i in range(box_width)] for j in range(box_height)]
            # сбрасываем игровые счетчики, кроме рекорда
            score = 0
            lines_total = 0
            cnt = 0
            cnt_inc = 50
            cnt_limit = 2000
            # выбираем новый фон
            bg_idx = randrange(13)
            # выводим в консоль диагностическое сообщение
            print("выбран следующий фон:", bg_idx)

    # рисуем содержимое главного буфера на дисплей
    pygame.display.flip()
    # делаем небольшую задержку согласно заданного FPS
    clock.tick(FPS)

# корректное завершение работы программы на основе библиотеки pygame
pygame.quit()
# ------------------------------------------------------------------------
# конец файла pyTetris.py
# ------------------------------------------------------------------------